# -*- coding: utf-8 -*-
##
##
## This file is part of Indico.
## Copyright (C) 2002 - 2014 European Organization for Nuclear Research (CERN).
##
## Indico is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 3 of the
## License, or (at your option) any later version.
##
## Indico is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Indico;if not, see <http://www.gnu.org/licenses/>.

from MaKaC.common.timezoneUtils import nowutc, setAdjustedDate, getAdjustedDate
from MaKaC.plugins.Collaboration.base import CSBookingBase
from MaKaC.common.utils import formatDateTime, validIP, unicodeLength, unicodeSlice
from MaKaC.plugins.Collaboration.CERNMCU.common import CERNMCUException, \
    ParticipantPerson, ParticipantRoom, getCERNMCUOptionValueByName, \
    CERNMCUError, handleSocketError, getMinStartDate, getMaxEndDate
from MaKaC.plugins.Collaboration.CERNMCU.mcu import MCU, MCUConfCommonParams, MCUTime, \
    paramsForLog, MCUParams, MCUParticipantCommonParams, datetimeFromMCUTime
from MaKaC.i18n import _

from xmlrpclib import Fault
from datetime import timedelta
from MaKaC.common.logger import Logger
from MaKaC.common.Counter import Counter
from MaKaC.services.interface.rpc.json import unicodeToUtf8
import socket
import re
from MaKaC.common.fossilize import fossilize

from MaKaC.plugins.Collaboration.CERNMCU.fossils import ICSBookingIndexingFossil
from MaKaC.common.fossilize import fossilizes
from MaKaC.plugins.Collaboration.fossils import ICSBookingBaseConfModifFossil


class CSBooking(CSBookingBase): #already Fossilizable
    fossilizes(ICSBookingBaseConfModifFossil, ICSBookingIndexingFossil)

    _hasTitle = True
    _hasStart = True
    _hasStop = True
    _hasStartStopAll = True
    _hasCheckStatus = True

    _requiresServerCallForStart = True
    _requiresClientCallForStart = False

    _requiresServerCallForStop = True
    _requiresClientCallForStop = False

    _needsBookingParamsCheck = True
    _needsToBeNotifiedOnView = True

    _hasEventDisplay = True

    _commonIndexes = ["All Videoconference"]

    _simpleParameters = {
        "name": (str, ''),
        "description": (str, ''),
        "id": (str, ''),
        "displayPin": (bool, False)}

    _complexParameters = ["pin", "hasPin", "autoGenerateId", "customId", "participants"]

    _participantNameRE = re.compile("^i-c(\d+)b(\d+)p(\d+)$")

    def __init__(self, bookingType, conf):
        CSBookingBase.__init__(self, bookingType, conf)

        self._oldName = None
        self._pin = None
        self._autoGeneratedId = None #boolean storing if the id was generated by Indico (True) or chosen by user (False)
        self._customId = None #the custom id chosen by the user, if any

        self._participants = {} #{id, Participant object}
        self._participantIdCounter = Counter(1)
        self._numberOfConnectedParticipants = 0
        self._numberOfDisconnectedParticipants = 0

        self._created = False
        self._creationTriesCounter = 0

    def canBeStarted(self):
        if self.isHappeningNow():
            return self._numberOfDisconnectedParticipants > 0
        else:
            return False

    def canBeStopped(self):
        if self.isHappeningNow():
            return self._numberOfConnectedParticipants > 0
        else:
            return False

    def getMCUStartTime(self):
        return MCUTime(self.getAdjustedStartDate(getCERNMCUOptionValueByName("MCUTZ")))

    def getDurationSeconds(self):
        diff = self.getEndDate() - self.getStartDate()

        #we have to do this for conferences where the start and end dates are on both sides of a summer time change
        #because the MCU is not timezone aware (blame the guy who programmed it)
        mcuTimezone = getCERNMCUOptionValueByName("MCUTZ")
        timeChangeDifference = self.getAdjustedStartDate(mcuTimezone).utcoffset() - self.getAdjustedEndDate(mcuTimezone).utcoffset()
        diff = diff - timeChangeDifference

        return diff.days * 86400 + diff.seconds

    def setDurationSeconds(self, durationSeconds):
        #we have to do this for conferences where the start and end dates are on both sides of a summer time change
        #because the MCU is not timezone aware (blame the guy who programmed it)
        tempEndDate = self.getStartDate() + timedelta(seconds = durationSeconds)
        mcuTimezone = getCERNMCUOptionValueByName("MCUTZ")
        timeChangeDifference = self.getAdjustedStartDate(mcuTimezone).utcoffset() - getAdjustedDate(tempEndDate, tz = mcuTimezone).utcoffset()

        self.setEndDate(tempEndDate + timeChangeDifference)

    def setAutoGenerateId(self, autoGenerateId):
        self._autoGeneratedId = (autoGenerateId == 'yes')

    def getAutoGenerateId(self):
        if self._autoGeneratedId:
            return 'yes'
        else:
            return 'no'

    def setCustomId(self, customId):
        self._customId = customId

    def getCustomId(self):
        if self._autoGeneratedId:
            return ''
        else:
            return self._customId

    def getPin(self):
        """ This method returns the pin that will be displayed in the indico page
        """
        return self._pin

    def setPin(self, pin):
        if not pin or pin.strip() == "":
            self._pin = ""
        else:
            self._pin = pin

    def getHasPin(self):
        return self._pin is not None and len(self._pin) > 0

    def setHasPin(self, value):
        #ignore, will be called only on rollback
        pass

    #particioant methods
    def getParticipantById(self, participantId):
        return self._participants[participantId]

    def getParticipantList(self, returnSorted = False):
        if returnSorted:
            keys = self._participants.keys()
            keys.sort()
            return [self._participants[k] for k in keys]
        else:
            return self._participants.values()

    def getParticipants(self):
        return fossilize(self.getParticipantList(returnSorted = True))

    def setParticipants(self, participants):
        """ Participants is an unpickled JSON object with the participant data.
            It will be a list of dictionaries.
        """

        participantsCopy = dict(self._participants)
        self._participants = {}

        for p in participants:

            participantId = p.get("participantId", None)

            if participantId is None or not participantId in participantsCopy: # new participant
                participantId = self._participantIdCounter.newCount()
                if p["type"] == 'person':
                    participantObject = ParticipantPerson(self, participantId, p)
                elif p["type"] == "room":
                    participantObject = ParticipantRoom(self, participantId, p)

            else: #already existing participant
                participantObject = participantsCopy[participantId]
                participantObject.updateData(p)

            self._participants[participantId] = participantObject

        self._p_changed = 1

    def updateNumberOfConnectedParticipants(self):
        connected, disconnected = 0, 0
        for participant in self.getParticipantList():
            if participant.getCallState() == "connected":
                connected += 1
            else:
                disconnected += 1

        # we do these checks since we don't want to write in the DB
        # unless we are sure the values changed
        # (avoids DB writes in display pages)

        if connected != self._numberOfConnectedParticipants:
            self._numberOfConnectedParticipants = connected

        if disconnected != self._numberOfDisconnectedParticipants:
            self._numberOfDisconnectedParticipants = disconnected

            if self._numberOfConnectedParticipants == 0:
                if self._numberOfDisconnectedParticipants == 0:
                    self._play_status = None
                else:
                    self._play_status = False
            else:
                self._play_status = True

    ## overriding methods
    def _getTitle(self):
        return self._bookingParams["name"]


    def _checkBookingParams(self):

        if len(self._bookingParams["name"].strip()) == 0:
            raise CERNMCUException("name parameter (" + str(self._bookingParams["name"]) +") is empty for booking with id: " + str(self._id))

        if unicodeLength(self._bookingParams["name"]) >= 32:
            raise CERNMCUException("name parameter (" + str(self._bookingParams["name"]) +") is longer than 31 characters for booking with id: " + str(self._id))

        self._bookingParams["name"] = self._bookingParams["name"].strip()

        if len(self._bookingParams["description"].strip()) == 0:
            raise CERNMCUException("description parameter (" + str(self._bookingParams["description"]) +") is empty for booking with id: " + str(self._id))

        if not self._autoGeneratedId:
            if len(self._customId.strip()) == 0:
                raise CERNMCUException("customId parameter (" + str(self._customId) +") is empty for booking with id: " + str(self._id))
            else:
                try:
                    int(self._customId)
                except ValueError:
                    raise CERNMCUException("customId parameter (" + str(self._customId) +") is not an integer for booking with id: " + str(self._id))
                if len(self._customId.strip()) != 5:
                    raise CERNMCUException("customId parameter (" + str(self._customId) +") is longer than 5 digits for booking with id: " + str(self._id))
                self._customId = int(self._customId)

        if self._pin:
            try:
                int(self._pin)
            except ValueError:
                raise CERNMCUException("pin parameter (" + str(self._pin) +") is not an integer for booking with id: " + str(self._id))

            if len(self._pin) >= 32:
                raise CERNMCUException("pin parameter (" + str(self._pin) +") is longer than 31 characters for booking with id: " + str(self._id))

        #if self.getAdjustedStartDate('UTC')  < (nowutc()):
        #    raise CERNMCUException("Cannot create booking in the past. Booking id: %s"% (str(self._id)))

        if self.getAdjustedEndDate('UTC')  < (nowutc()):
            raise CERNMCUException("End date cannot be in the past. Booking id: %s"% (str(self._id)))

        minStartDate = getMinStartDate(self.getConference())
        if self.getAdjustedStartDate() < minStartDate:
            raise CERNMCUException("Cannot create a booking before the Indico event's start date. Please create it after %s"%(formatDateTime(minStartDate)))

        maxEndDate = getMaxEndDate(self.getConference())
        if self.getAdjustedStartDate() > maxEndDate:
            raise CERNMCUException("Cannot create a booking after before the Indico event's end date. Please create it after %s"%(formatDateTime(maxEndDate)))

        pSet = set()
        ipSet = set()

        for p in self._participants.itervalues():

            if not validIP(p.getIp()):
                raise CERNMCUException("Participant has not a correct ip. (ip string= " + p.getIp() + ")")

            if p.getType() == 'person':
                if not p.getFamilyName():
                    raise CERNMCUException(_("Participant (person) does not have family name."))
                if not p.getFirstName():
                    raise CERNMCUException(_("Participant (person) does not have first name."))
            elif p.getType() == 'room':
                if not p.getName():
                    raise CERNMCUException(_("Participant (room) does not have name."))

            ip = p.getIp()
            if ip in ipSet:
                raise CERNMCUException(_("At least two of the participants have the same IP. Please change this"))
            else:
                ipSet.add(ip)

        return False

    def _create(self):
        if self._autoGeneratedId:
            if self._creationTriesCounter < 100:
                numericId = self._plugin.getGlobalData().getNewConferenceId()
            else:
                return CERNMCUError('tooManyTries', "Could not obtain ID")
        else:
            numericId = self._customId

        try:
            mcu = MCU.getInstance()
            params = MCUConfCommonParams(conferenceName = self._bookingParams["name"],
                                         numericId = str(numericId),
                                         startTime = self.getMCUStartTime(),
                                         durationSeconds = self.getDurationSeconds(),
                                         pin = self._pin,
                                         description = unicodeSlice(self._bookingParams["description"], 0, 31),
                                        )
            Logger.get('CERNMCU').info("""Evt:%s, booking:%s, calling conference.create with params: %s""" % (self._conf.getId(), self.getId(), str(paramsForLog(params))))
            answer = unicodeToUtf8(mcu.conference.create(params))
            Logger.get('CERNMCU').info("""Evt:%s, booking:%s, calling conference.create. Got answer: %s""" % (self._conf.getId(), self.getId(), str(answer)))

            for p in self._participants.itervalues():
                result = self.addParticipant(p)
                if not result is True:
                    return result

            self._bookingParams["id"] = numericId
            self._oldName = self._bookingParams["name"]
            self._created = True

            self.updateNumberOfConnectedParticipants()

        except Fault, e:
            Logger.get('CERNMCU').warning("""Evt:%s, calling conference.create. Got error: %s""" % (self._conf.getId(), str(e)))
            return self.handleFault('create', e)

        except socket.error, e:
            handleSocketError(e)

    def _modify(self, oldBookingParams):
        """ Relays to the MCU the changes done by the user to the Indico booking object.
            For the participants, we retrieve a list of existing participants.
            If a participant is both in the MCU and the Indico booking, it is not touched.
            Thus, we only delete in the MCU those having been removed, and we only create only those who have been added.
            In this way we avoid disconnection of already connected participants.
        """

        if self._created:

            if self._autoGeneratedId:
                numericId = self._bookingParams["id"]
            else:
                numericId = self._customId

            try:
                mcu = MCU.getInstance()
                params = MCUConfCommonParams(
                    conferenceName = self._oldName,
                    newConferenceName = self._bookingParams["name"],
                    numericId = str(numericId),
                    startTime = self.getMCUStartTime(),
                    durationSeconds = self.getDurationSeconds(),
                    pin = self._pin,
                    description = self._bookingParams["description"])

                Logger.get('CERNMCU').debug(
                    "Evt: %s, booking: %s, calling conference.modify with params: %s" %
                    (self._conf.getId(), self.getId(), str(paramsForLog(params))))

                answer = unicodeToUtf8(mcu.conference.modify(params))

                Logger.get('CERNMCU').debug(
                    "Evt: %s, booking: %s, calling conference.modify. Got answer: %s" %
                    (self._conf.getId(), self.getId(), str(answer)))
                self._bookingParams["id"] = numericId
                self._oldName = self._bookingParams["name"]

                #we take care of the participants
                previousParticipantList = oldBookingParams["participants"]
                previousParticipantDict = dict(
                    (pData["participantName"], pData)
                    for pData in previousParticipantList)

                # participants indexed by name
                # (maybe they should be indexed by name by default?)
                participantDict = dict(
                    (p.getParticipantName(), p)
                    for p in self._participants.itervalues())

                currParticipantSet = set(participantDict)
                prevParticipantSet = set(previousParticipantDict)

                # lists of participants to be added, removed or edited
                addList = currParticipantSet - prevParticipantSet
                editList = currParticipantSet.intersection(prevParticipantSet)
                removeList = prevParticipantSet - editList

                # we add the new participants
                for name in addList:
                    result = self.addParticipant(participantDict[name])
                    if not result is True:
                            return result

                #for the participants that exist both in Indico and the MCU,
                #we re-add them if the IP has changed,
                #or we just modify the displayName if the IP has not changed
                for name in editList:

                    participant = participantDict[name]
                    existingData = previousParticipantDict[name]

                    if (existingData["ip"] != participant.getIp() and \
                        existingData["participantType"] == "by_address") or \
                        (existingData["participantProtocol"] != participant.getParticipantProtocol()):

                        result = self.modifyParticipantAllData(participant,
                                                               existingData)

                        if not result is True:
                            return result

                    elif existingData["displayName"] != participant.getDisplayName():
                        result = self.modifyParticipantDisplayName(participantName,
                                                                   participant.getParticipantType(),
                                                                   participant.getParticipantProtocol(),
                                                                   participant.getDisplayName())
                        if not result is True:
                            return result

                #we remove the participants existed previously but have been removed
                for name in removeList:
                    existingData = previousParticipantDict[name]
                    if not existingData["participantType"] == "by_name" and not existingData["callState"] == "disconnected":
                        result = self.removeParticipant(existingData["participantName"],
                                                        existingData["participantType"],
                                                        existingData["participantProtocol"])
                        if not result is True:
                            return result

                self._created = True
                self.updateNumberOfConnectedParticipants()

            except Fault, e:
                Logger.get('CERNMCU').warning("""Evt:%s, booking:%s, calling conference.modify. Got error: %s""" % (self._conf.getId(), self.getId(), str(e)))
                return self.handleFault('modify', e)

            except socket.error, e:
                handleSocketError(e)

        else: #not yet created because of errors: try to recreate
            self._create()

    def _start(self):
        self._checkStatus()
        if self.canBeStarted():
            for p in self.getParticipantList(returnSorted = True):
                self._connectParticipant(p)

            # True = started
        self.updateNumberOfConnectedParticipants()

    def _connectParticipant(self, participant):
        """
        Tries to actually connect a participant using the MCU.
        Returns a Fault object in case something goes wrong,
        None otherwise
        """

        try:
            self.updateNumberOfConnectedParticipants()
            mcu = MCU.getInstance()
            if (participant.getCallState() == "disconnected" or participant.getCallState() == "dormant") and participant.getParticipantType() != "ad_hoc":
                params = MCUParams(conferenceName = self._bookingParams["name"],
                                   participantName = participant.getParticipantName(),
                                   participantType = participant.getParticipantType(),
                                   participantProtocol = participant.getParticipantProtocol())
                Logger.get('CERNMCU').info("""Evt:%s, booking:%s, calling participant.connect with params: %s""" % (self._conf.getId(), self.getId(), str(paramsForLog(params))))
                answer = unicodeToUtf8(mcu.participant.connect(params))
                Logger.get('CERNMCU').info("""Evt:%s, booking:%s, calling participant.connect. Got answer: %s""" % (self._conf.getId(), self.getId(), str(answer)))

                participant.setCallState("connected")
                self.updateNumberOfConnectedParticipants()

        except Fault, e:
            Logger.get('CERNMCU').warning("""Evt:%s, booking:%s, calling participant.connect. Got error: %s""" % (self._conf.getId(), self.getId(), str(e)))
            fault = self.handleFault('start', e)
            if fault:
                return fault

        except socket.error, e:
            handleSocketError(e)

    def startSingleParticipant(self, participant):
        self._checkStatus()
        if self.canBeStarted():
            result = self._connectParticipant(participant)
            return result
        self.updateNumberOfConnectedParticipants()

    def _stop(self):
        self._checkStatus()
        if self.canBeStopped():
            for p in self.getParticipantList(returnSorted = True):
                self._disconnectParticipant(p)

            # False = stopped

        self.updateNumberOfConnectedParticipants()

    def _disconnectParticipant(self, participant):
        try:
            self.updateNumberOfConnectedParticipants()
            mcu = MCU.getInstance()

            if participant.getCallState() == "connected":
                params = MCUParams(conferenceName = self._bookingParams["name"],
                                   participantName = participant.getParticipantName(),
                                   participantType = participant.getParticipantType(),
                                   participantProtocol = participant.getParticipantProtocol())

                Logger.get('CERNMCU').info("""Evt:%s, booking:%s, calling participant.disconnect with params: %s""" % (self._conf.getId(), self.getId(), str(paramsForLog(params))))
                answer = unicodeToUtf8(mcu.participant.disconnect(params))
                Logger.get('CERNMCU').info("""Evt:%s, booking:%s, calling participant.disconnect. Got answer: %s""" % (self._conf.getId(), self.getId(), str(answer)))

                participant.setCallState("disconnected")

            # if participant is Ad Hoc, get rid of it
            if not participant.isCreatedByIndico():
                # not a local...
                del self._participants[participant.getId()]

            self.updateNumberOfConnectedParticipants()

        except Fault, e:
            Logger.get('CERNMCU').warning("""Evt:%s, booking:%s, calling participant.disconnect. Got error: %s""" % (self._conf.getId(), self.getId(), str(e)))
            fault = self.handleFault('stop', e)
            if fault:
                return fault

        except socket.error, e:
            handleSocketError(e)

    def stopSingleParticipant(self, participant):
        self._checkStatus()
        if self.canBeStopped():
            result = self._disconnectParticipant(participant)
            return result

    def _notifyOnView(self):
        pass

    def _checkStatus(self):
        if self._created:
            self.updateNumberOfConnectedParticipants()
            self.queryConference()
            self._cleanupAdHocParticipants()

    def _delete(self):
        if self._created:
            name = self._bookingParams["name"]

            try:
                mcu = MCU.getInstance()
                params = MCUParams(conferenceName = name)
                Logger.get('CERNMCU').info("""Evt:%s, booking:%s, calling conference.destroy with params: %s""" % (self._conf.getId(), self.getId(), str(paramsForLog(params))))
                answer = unicodeToUtf8(mcu.conference.destroy(params))
                Logger.get('CERNMCU').info("""Evt:%s, booking:%s, calling conference.destroy. Got answer: %s""" % (self._conf.getId(), self.getId(), str(answer)))

                self._created = False

            except Fault, e:
                Logger.get('CERNMCU').warning("""Evt:%s, booking:%s, calling conference.destroy. Got error: %s""" % (self._conf.getId(), self.getId(), str(e)))
                if e.faultCode == 4: #conference didn't exist in the MCU, but we delete it from Indico anyway
                    pass
                else:
                    return self.handleFault('delete', e)
            except socket.error, e:
                handleSocketError(e)

    ## end of overrided methods

    def addParticipant(self, participant):
        """ Adds a participant to the MCU conference represented by this booking.
            participant: a Participant object
            returns: True if successful, a CERNMCUError if there is a problem in some cases, raises an Exception in others
        """
        try:
            mcu = MCU.getInstance()

            params = MCUParticipantCommonParams(conferenceName = self._bookingParams["name"],
                                                participantName = participant.getParticipantName(),
                                                displayNameOverrideValue = participant.getDisplayName(),
                                                address = participant.getIp(),
                                                participantProtocol = participant.getParticipantProtocol()
                                                )
            Logger.get('CERNMCU').info("""Evt:%s, booking:%s, calling participant.add with params: %s""" % (self._conf.getId(), self.getId(), str(paramsForLog(params))))
            answer = unicodeToUtf8(mcu.participant.add(params))
            Logger.get('CERNMCU').info("""Evt:%s, booking:%s, calling participant.add. Got answer: %s""" % (self._conf.getId(), self.getId(), str(answer)))


            if self._numberOfConnectedParticipants > 0:
                #we have to connect the new participant
                self._connectParticipant(participant)

            return True

        except Fault, e:
            Logger.get('CERNMCU').warning("""Evt:%s, calling participant.add. Got error: %s""" % (self._conf.getId(), str(e)))
            fault = self.handleFault('add', e)
            fault.setInfo(participant.getIp())
            return fault

    def modifyParticipantAllData(self, participant, existingData):
        """
        Modifies a participant, by removing and re-adding.
        participant is a Participant object and existingData a dictionary
        """

        result = self.removeParticipant(
            existingData["participantName"],
            existingData["participantType"],
            existingData["participantProtocol"])

        if not result is True:
            return result

        result = self.addParticipant(participant)

        return result

    def modifyParticipantDisplayName(self, participantName, participantType, participantProtocol, newDisplayName):
        """ Modifies the display name of a participant
            returns: True if successful, a CERNMCUError if there is a problem in some cases, raises an Exception in others
        """
        try:
            mcu = MCU.getInstance()

            params = MCUParticipantCommonParams(
                conferenceName = self._bookingParams["name"],
                participantName = participantName,
                participantType = participantType,
                participantProtocol = participantProtocol,
                displayNameOverrideValue = newDisplayName)

            Logger.get('CERNMCU').info(
                "Evt: %s, booking: %s, calling participant.modify with params: %s" %
                (self._conf.getId(), self.getId(), str(paramsForLog(params))))

            answer = unicodeToUtf8(mcu.participant.modify(params))

            Logger.get('CERNMCU').info(
                "Evt:%s, booking:%s, calling participant.modify. Got answer: %s" %
                (self._conf.getId(), self.getId(), str(answer)))

            return True
        except Fault, e:
            Logger.get('CERNMCU').warning("""Evt:%s, calling participant.modify. Got error: %s""" % (self._conf.getId(), str(e)))
            fault = self.handleFault('modifyParticipant', e)
            fault.setInfo(participantName)
            return fault

    def removeParticipant(self, participantName, participantType, participantProtocol):
        """ Removes a participant to the MCU conference represented by this booking.
            participant: a participant name like the one returned by Participant.getParticipantName
            returns: True if successful, a CERNMCUError if there is a problem in some cases, raises an Exception in others
        """
        try:
            mcu = MCU.getInstance()

            params = MCUParams(conferenceName = self._bookingParams["name"],
                               participantName = participantName,
                               participantType = participantType,
                               participantProtocol = participantProtocol)
            Logger.get('CERNMCU').info("""Evt:%s, booking:%s, calling participant.remove with params: %s""" % (self._conf.getId(), self.getId(), str(paramsForLog(params))))
            answer = unicodeToUtf8(mcu.participant.remove(params))
            Logger.get('CERNMCU').info("""Evt:%s, booking:%s, calling participant.remove. Got answer: %s""" % (self._conf.getId(), self.getId(), str(answer)))
            return True
        except Fault, e:
            Logger.get('CERNMCU').warning("""Evt:%s, calling participant.remove. Got error: %s""" % (self._conf.getId(), str(e)))
            return self.handleFault('remove', e)

    def _cleanupAdHocParticipants(self):
        """
        Remove ad-hoc participants that had been disconnected
        """

        for pId, participant in self._participants.items():
            if participant.getCallState() == "disconnected" and \
               not participant.isCreatedByIndico():
                # disconnected, not local
                # remove from the participant dictionary
                del self._participants[pId]


    def _updateAdHocParticipant(self, name, attrs):
        """
        Sets the data for a new ad-hoc participant
        """

        newId = self._participantIdCounter.newCount()
        self._participants[newId] = ParticipantRoom(self,
                                                    newId,
                                                    {"name": attrs["displayName"],
                                                     "ip": attrs["ip"]},
                                                    participantName=name,
                                                    createdByIndico=False)
        self._participants[newId].setParticipantType(attrs["participantType"])
        self._participants[newId].setParticipantProtocol(attrs["participantProtocol"])
        self._participants[newId].setCallState(attrs["callState"])


    def _processQueryConference(self, conference):
        """
        Processe an individual conference result from an `enumerate` query
        This is a helper method for queryConference
        """

        # we update the local Indico description
        remoteDescription = conference.get("description", '')
        if unicodeLength(remoteDescription) < 31 or \
               not self._bookingParams["description"].startswith(remoteDescription):
            self._bookingParams["description"] = remoteDescription

        # we update the local id
        self._bookingParams["id"] = conference.get("numericId", '')
        if not self._autoGeneratedId:
            self._customId = self._bookingParams["id"]

        self._oldName = self._bookingParams["name"]

        # we update the local PIN
        self._pin = conference.get("pin", '')

        # we obtain the remote list of participants in the MCU
        remoteParticipants = self.queryParticipants()

        # participants/ids indexed by Name
        # (maybe they should be indexed by name by default?)
        participantDict = dict(
            (p.getParticipantName(), (k,p))
            for k, p in self._participants.iteritems())

        remoteNames = set(remoteParticipants)
        localNames = set(p.getParticipantName()
                         for p in self._participants.itervalues())

        # participants that only exist locally (not yet added remotely)
        localOnlyNames = localNames - remoteNames
        # participants that exist both locally and in the MCU
        commonNames = localNames & remoteNames
        # participants that were added remotely (MCU)
        mcuOnlyNames = remoteNames - localNames

        # if a participant has been removed remotely, we remove it locally
        # don't use iteritems, we need a copy
        for name in localOnlyNames:
            pId, __ = participantDict[name]
            del self._participants[pId]

        # for participants that are both in the MCU and Indico,
        # we update some of their attributes in Indico
        for name in commonNames:
            pId, participant = participantDict[name]
            remoteData = remoteParticipants[name]
            remoteDispName = remoteData["displayName"]

            if participant.getDisplayName() != remoteDispName:
                # the display name was updated remotely
                if participant.getType() == 'room':
                    participant.setName(remoteDispName)
                    participant.setInstitution(remoteDispName)
                else:
                    self._participants[pId] = \
                        ParticipantRoom(self,
                                        pId,
                                        {"name": remoteDispName},
                                        createdByIndico=True)

            participant.setParticipantType(remoteData["participantType"])
            participant.setParticipantProtocol(remoteData["participantProtocol"])
            participant.setCallState(remoteData["callState"])

        # we try to add to Indico participants that were added
        # to the MCU (by an operator or by people joining ad hoc)
        for name in mcuOnlyNames:

            attrs = remoteParticipants[name]

            # only for participants that are not already in
            # disconnected state
            if attrs["callState"] != "disconnected":
                self._updateAdHocParticipant(name, attrs)

        startTime = conference.get("startTime", None)
        if startTime:
            adjustedDate = setAdjustedDate(datetimeFromMCUTime(startTime), tz = getCERNMCUOptionValueByName("MCUTZ"))
            self.setStartDate(adjustedDate)

        durationSeconds = conference.get("durationSeconds", None)
        if durationSeconds:
            self.setDurationSeconds(durationSeconds)
        else:
            self.setEndDate(self.getStartDate())


    def queryConference(self):
        """ Queries the MCU for information about a conference with the same conferenceName as self._bookingParams["name"]
            If found, the attributes of the Indico booking object are updated, included the participants.
            If not found, an error message will appear and the conference will be marked as not created.
        """
        try:
            mcu = MCU.getInstance()

            enumerateID = None
            keepAsking = True
            found = False

            while keepAsking and not found:
                if enumerateID:
                    params = MCUParams(enumerateID = enumerateID)
                else:
                    params = MCUParams()

                Logger.get('CERNMCU').info(
                    "Evt:%s, booking:%s, calling conference.enumerate with params: %s"
                    % (self._conf.getId(), self.getId(), str(paramsForLog(params))))

                answer = unicodeToUtf8(mcu.conference.enumerate(params))
                #un-comment to print all the garbage about other conferences received
                # Logger.get('CERNMCU').debug(
                #    "Evt:%s, booking:%s, calling conference.enumerate. Got answer: %s" %
                #    (self._conf.getId(), self.getId(), str(answer)))

                # we loop through all the returned output
                for conference in answer.get("conferences", []):
                    if conference.get("conferenceName", None) == \
                           self._bookingParams["name"]:

                        # we found our conference
                        found = True

                        Logger.get('CERNMCU').info(
                            "Evt:%s, booking:%s, calling conference.enumerate. Found conference:\n%s" %
                            (self._conf.getId(), self.getId(), str(conference)))

                        self._processQueryConference(conference)

                        # mark it as created, and stop the cycle
                        self._created = True
                        break


                enumerateID = answer.get("enumerateID", None)
                keepAsking = enumerateID is not None

            if not found:
                self._created = False

            self._p_changed = 1

        except Fault, e:
            Logger.get('CERNMCU').warning("""Evt:%s, booking:%s, calling participants.enumerate. Got error: %s""" % (self._conf.getId(), self.getId(), str(e)))
            raise
        except socket.error, e:
            handleSocketError(e)

    def queryParticipants(self):
        """ Queries the MCU for the list of participants of this conference,
            using participant.enumerate.
            Each "participant" returned by the MCU is a dictionary with several keys.
            Only the "participantName", "displayName", "address", "callState" and "conferenceName" values are important for us.
            If the "conferenceName" value matches our booking name, then we have a participant from our conference.
            We return a dictionary like this:
            -key: the participantName of a participant
            -value: a dictionary, with the participant data retrieved from the MCU
        """
        try:
            mcu = MCU.getInstance()
            participants = {} #key = participantName, value = {displayName, ip}

            enumerateID = None
            keepAsking = True

            while keepAsking:
                if enumerateID:
                    params = MCUParams(enumerateID = enumerateID)
                else:
                    params = MCUParams()

                Logger.get('CERNMCU').info("""Evt:%s, booking:%s, calling participants.enumerate with params: %s""" % (self._conf.getId(), self.getId(), str(paramsForLog(params))))
                answer = unicodeToUtf8(mcu.participant.enumerate(params))
                #un-comment to print all the garbage received about other participants
                #Logger.get('CERNMCU').debug("""Evt:%s, booking:%s, calling participants.enumerate. Got answer: %s""" % (self._conf.getId(), self.getId(), str(answer)))

                for participant in answer.get("participants", []):
                    if participant.get("conferenceName", None) == self._bookingParams["name"]:
                        Logger.get('CERNMCU').info("""Evt:%s, booking:%s, calling participants.enumerate. Found participant:\n%s""" % (self._conf.getId(), self.getId(), str(participant)))

                        name = participant.get("participantName", None)
                        displayName = participant.get("displayName", None)
                        participantType = participant.get("participantType", None)
                        participantProtocol = participant.get("participantProtocol", None)
                        callState = participant.get("callState", None)
                        ip = participant.get("address", None)

                        if name:
                            participants[name] = {"displayName": displayName,
                                                  "ip": ip,
                                                  "participantType": participantType,
                                                  "participantProtocol": participantProtocol,
                                                  "callState": callState}

                enumerateID = answer.get("enumerateID", None)
                keepAsking = enumerateID is not None

            return participants


        except Fault, e:
            Logger.get('CERNMCU').warning("""Evt:%s, booking:%s, calling participants.enumerate. Got error: %s""" % (self._conf.getId(), self.getId(), str(e)))
            raise
        except socket.error, e:
            handleSocketError(e)

    def handleFault(self, operation, e):

        if e.faultCode == 14: #authorization error
            raise CERNMCUException(_("Authorization Error while Indico tried to connect to the MCU.\nPlease report to Indico support."), e)

        if operation == 'create' or operation == 'modify':
            if e.faultCode == 2: #duplicated name
                fault = CERNMCUError(e.faultCode)
                return fault
            if e.faultCode == 6: #too many conferences in MCU, no more can be created
                fault = CERNMCUError(e.faultCode)
                return fault
            elif e.faultCode == 18:  #duplicated ID
                if self._autoGeneratedId:
                    self._creationTriesCounter = self._creationTriesCounter + 1
                    return self._create()
                else:
                    fault = CERNMCUError(e.faultCode)
                    return fault
            else: #another error
                raise CERNMCUException(_("Problem with the MCU while creating or modifying a conference"), e)

        elif operation == 'delete':
            raise CERNMCUException(_("Problem with the MCU while removing a conference"), e)

        elif operation == 'add':
            if e.faultCode == 3: #duplicate participant name
                fault = CERNMCUError(e.faultCode)
                return fault
            if e.faultCode == 7: #too many participants in MCU, no more can be created
                fault = CERNMCUError(e.faultCode)
                return fault
            else:
                raise CERNMCUException(_("Problem with the MCU while adding a participant"), e)

        elif operation == 'modifyParticipant':
            raise CERNMCUException(_("Problem with the MCU while modifying the name of a participant"), e)

        elif operation == 'remove':
            raise CERNMCUException(_("Problem with the MCU while removing a participant"), e)

        elif operation == 'start':
            if e.faultCode == 201: #we tried to connect a participant that could not be connected
                fault = CERNMCUError(e.faultCode)
                return fault
            raise CERNMCUException(_("Problem with the MCU while starting a conference"), e)

        elif operation == 'stop':
            if e.faultCode == 201: #we tried to disconnect a participant that was not connected
                fault = CERNMCUError(e.faultCode)
                return fault
            elif e.faultCode == 5: #we tried to disconnect a participant that didn't exist
                fault = CERNMCUError(e.faultCode)
                return fault
            else:
                raise CERNMCUException(_("Problem with the MCU while stopping a conference"), e)
